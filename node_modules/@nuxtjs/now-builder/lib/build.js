"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const resolve_from_1 = __importDefault(require("resolve-from"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const semver_1 = require("semver");
const consola_1 = __importDefault(require("consola"));
const build_utils_1 = require("@now/build-utils");
const utils_1 = require("./utils");
const typescript_1 = require("./typescript");
async function build({ files, entrypoint, workPath, config = {}, meta = {} }) {
    // ----------------- Prepare build -----------------
    utils_1.startStep('Prepare build');
    // Validate entrypoint
    utils_1.validateEntrypoint(entrypoint);
    // Entry directory
    const entryDir = path_1.default.dirname(entrypoint);
    // Compute rootDir
    const rootDir = path_1.default.join(workPath, entryDir);
    // Create a real filesystem
    consola_1.default.log('Downloading files...');
    await build_utils_1.download(files, workPath, meta);
    // Change cwd to rootDir
    process.chdir(rootDir);
    consola_1.default.log('Working directory:', process.cwd());
    // Read package.json
    let pkg;
    try {
        pkg = await fs_extra_1.default.readJson('package.json');
    }
    catch (e) {
        throw new Error(`Can not read package.json from ${rootDir}`);
    }
    // Node version
    const nodeVersion = await build_utils_1.getNodeVersion(rootDir);
    const spawnOpts = build_utils_1.getSpawnOptions(meta, nodeVersion);
    // Prepare TypeScript environment if required.
    const usesTypescript = (pkg.devDependencies && Object.keys(pkg.devDependencies).includes('@nuxt/typescript-build')) || (pkg.dependencies && Object.keys(pkg.dependencies).includes('@nuxt/typescript'));
    const needsTypescriptBuild = utils_1.getNuxtConfigName(rootDir) === 'nuxt.config.ts';
    if (usesTypescript) {
        await typescript_1.prepareTypescriptEnvironment({
            pkg, spawnOpts, rootDir
        });
    }
    // Detect npm (prefer yarn)
    const isYarn = !fs_extra_1.default.existsSync('package-lock.json');
    consola_1.default.log('Using', isYarn ? 'yarn' : 'npm');
    // Write .npmrc
    if (process.env.NPM_AUTH_TOKEN) {
        consola_1.default.log('Found NPM_AUTH_TOKEN in environment, creating .npmrc');
        await fs_extra_1.default.writeFile('.npmrc', `//registry.npmjs.org/:_authToken=${process.env.NPM_AUTH_TOKEN}`);
    }
    // Write .yarnclean
    if (isYarn && !fs_extra_1.default.existsSync('.yarnclean')) {
        await fs_extra_1.default.copyFile(path_1.default.join(__dirname, '.yarnclean'), '.yarnclean');
    }
    // Cache dir
    const cacheDir = path_1.default.resolve(rootDir, '.now_cache');
    await fs_extra_1.default.mkdirp(cacheDir);
    const yarnCacheDir = path_1.default.join(cacheDir, 'yarn');
    await fs_extra_1.default.mkdirp(yarnCacheDir);
    // ----------------- Install devDependencies -----------------
    utils_1.startStep('Install devDependencies');
    // Prepare node_modules
    await fs_extra_1.default.mkdirp('node_modules_dev');
    if (fs_extra_1.default.existsSync('node_modules')) {
        await fs_extra_1.default.unlink('node_modules');
    }
    await fs_extra_1.default.symlink('node_modules_dev', 'node_modules');
    // Install all dependencies
    if (isYarn) {
        await utils_1.exec('yarn', [
            'install',
            '--prefer-offline',
            '--frozen-lockfile',
            '--non-interactive',
            '--production=false',
            `--modules-folder=${rootDir}/node_modules`,
            `--cache-folder=${yarnCacheDir}`
        ], { ...spawnOpts, env: { ...spawnOpts.env, NODE_ENV: 'development' } });
    }
    else {
        await utils_1.exec('npm', ['install'], { ...spawnOpts, env: { ...spawnOpts.env, NODE_ENV: 'development' } });
    }
    // ----------------- Nuxt build -----------------
    utils_1.startStep('Nuxt build');
    let compiledTypescriptFiles = {};
    if (needsTypescriptBuild) {
        const tscOptions = config.tscOptions;
        compiledTypescriptFiles = await typescript_1.compileTypescriptBuildFiles({ rootDir, spawnOpts, tscOptions });
    }
    // Read nuxt.config.js
    const nuxtConfigName = 'nuxt.config.js';
    const nuxtConfigFile = utils_1.getNuxtConfig(rootDir, nuxtConfigName);
    // Read options from nuxt.config.js otherwise set sensible defaults
    const staticDir = (nuxtConfigFile.dir && nuxtConfigFile.dir.static) ? nuxtConfigFile.dir.static : 'static';
    const publicPath = ((nuxtConfigFile.build && nuxtConfigFile.build.publicPath) ? nuxtConfigFile.build.publicPath : '/_nuxt/').replace(/^\//, '');
    const buildDir = nuxtConfigFile.buildDir ? path_1.default.relative(rootDir, nuxtConfigFile.buildDir) : '.nuxt';
    const lambdaName = nuxtConfigFile.lambdaName ? nuxtConfigFile.lambdaName : 'index';
    // Execute nuxt build
    if (fs_extra_1.default.existsSync(buildDir)) {
        consola_1.default.warn(buildDir, 'exists! Please ensure to ignore it with `.nowignore`');
    }
    await utils_1.exec('nuxt', [
        'build',
        '--standalone',
        '--no-lock',
        `--config-file "${nuxtConfigName}"`
    ], spawnOpts);
    // ----------------- Install dependencies -----------------
    utils_1.startStep('Install dependencies');
    // Use node_modules_prod
    await fs_extra_1.default.mkdirp('node_modules_prod');
    if (fs_extra_1.default.existsSync('node_modules')) {
        await fs_extra_1.default.unlink('node_modules');
    }
    await fs_extra_1.default.symlink('node_modules_prod', 'node_modules');
    // Only keep core dependency
    const nuxtDep = utils_1.preparePkgForProd(pkg);
    await fs_extra_1.default.writeJSON('package.json', pkg);
    if (isYarn) {
        await utils_1.exec('yarn', [
            'install',
            '--prefer-offline',
            '--pure-lockfile',
            '--non-interactive',
            '--production=true',
            `--modules-folder=${rootDir}/node_modules`,
            `--cache-folder=${yarnCacheDir}`
        ], spawnOpts);
    }
    else {
        await utils_1.exec('npm', ['install'], spawnOpts);
    }
    // Validate nuxt version
    const nuxtPkg = require(resolve_from_1.default(rootDir, `@nuxt/core${nuxtDep.suffix}/package.json`));
    if (!semver_1.gte(nuxtPkg.version, '2.4.0')) {
        throw new Error(`nuxt >= 2.4.0 is required, detected version ${nuxtPkg.version}`);
    }
    if (semver_1.gt(nuxtPkg.version, '3.0.0')) {
        consola_1.default.warn('WARNING: nuxt >= 3.0.0 is not tested against this builder!');
    }
    // Cleanup .npmrc
    if (process.env.NPM_AUTH_TOKEN) {
        await fs_extra_1.default.unlink('.npmrc');
    }
    // ----------------- Collect artifacts -----------------
    utils_1.startStep('Collect artifacts');
    // Static files
    const staticFiles = await build_utils_1.glob('**', path_1.default.join(rootDir, staticDir));
    // Client dist files
    const clientDistDir = path_1.default.join(rootDir, buildDir, 'dist/client');
    const clientDistFiles = await utils_1.globAndPrefix('**', clientDistDir, publicPath);
    // Server dist files
    const serverDistDir = path_1.default.join(rootDir, buildDir, 'dist/server');
    const serverDistFiles = await utils_1.globAndPrefix('**', serverDistDir, path_1.default.join(buildDir, 'dist/server'));
    // node_modules_prod
    const nodeModulesDir = path_1.default.join(rootDir, 'node_modules_prod');
    const nodeModules = await utils_1.globAndPrefix('**', nodeModulesDir, 'node_modules');
    // Lambdas
    const lambdas = {};
    const launcherPath = path_1.default.join(__dirname, 'launcher.js');
    const launcherSrc = (await fs_extra_1.default.readFile(launcherPath, 'utf8'))
        .replace(/__NUXT_SUFFIX__/g, nuxtDep.suffix)
        .replace(/__NUXT_CONFIG__/g, './' + nuxtConfigName);
    const launcherFiles = {
        'now__launcher.js': new build_utils_1.FileBlob({ data: launcherSrc }),
        'now__bridge.js': new build_utils_1.FileFsRef({ fsPath: require('@now/node-bridge') }),
        [nuxtConfigName]: new build_utils_1.FileFsRef({ fsPath: path_1.default.resolve(rootDir, nuxtConfigName) }),
        ...serverDistFiles,
        ...compiledTypescriptFiles,
        ...nodeModules
    };
    // Extra files to be included in lambda
    const serverFiles = [
        ...(Array.isArray(config.serverFiles) ? config.serverFiles : []),
        'package.json'
    ];
    for (const pattern of serverFiles) {
        const files = await build_utils_1.glob(pattern, rootDir);
        Object.assign(launcherFiles, files);
    }
    // lambdaName will be titled index, unless specified in nuxt.config.js
    lambdas[lambdaName] = await build_utils_1.createLambda({
        handler: 'now__launcher.launcher',
        runtime: meta.isDev ? 'nodejs' : nodeVersion.runtime,
        files: launcherFiles,
        environment: {
            NODE_ENV: 'production'
        }
    });
    // await download(launcherFiles, rootDir)
    utils_1.endStep();
    return {
        output: {
            ...lambdas,
            ...clientDistFiles,
            ...staticFiles
        },
        routes: [
            { src: `/${publicPath}.+`, headers: { 'Cache-Control': 'max-age=31557600' } },
            ...Object.keys(staticFiles).map(file => ({ src: `/${file}`, headers: { 'Cache-Control': 'max-age=31557600' } })),
            { src: '/(.*)', dest: '/' }
        ]
    };
}
exports.build = build;
